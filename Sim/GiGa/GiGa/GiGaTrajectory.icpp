/// ===========================================================================
/// CVS tag $Name: not supported by cvs2svn $ 
/// ===========================================================================
/// $Log: not supported by cvs2svn $ 
/// ===========================================================================
#ifndef    GIGA_GIGATRAJECTORY_ICPP
#define    GIGA_GIGATRAJECTORY_ICPP 1 
/// ===========================================================================
/// STL 
#include <vector>
#include <algorithm>
#include <functional>
/// Geant4 
#include "G4Step.hh"
#include "G4Track.hh"
/// GiGa 
#include "GiGa/GiGaTrajectoryPoint.h"
#include "GiGa/GiGaTrajectory.h"
///

/** implementation of inline methods form class GiGaTrajectory
 *
 *  @author Vanya Belayev 
 */

/// ===========================================================================
/// allocator 
/// ===========================================================================
extern G4Allocator<GiGaTrajectory> s_GiGaTrajectoryAllocator;

/// ===========================================================================
/// constructor 
/// ===========================================================================
inline GiGaTrajectory::GiGaTrajectory (   )
  : G4VTrajectory                     (   ) 
  , std::vector<GiGaTrajectoryPoint*> (   ) 
  , m_trackID                         ( 0 ) 
  , m_parentID                        ( 0 )
  , m_partDef                         ( 0 ) 
  , m_4vect                           (   )
  , m_stepMgr                         ( 0 )
{};

/// ===========================================================================
/// constructor 
/// ===========================================================================
inline GiGaTrajectory::GiGaTrajectory   ( const G4Track* aTrack )
  : G4VTrajectory(                                              ) 
  , std::vector<GiGaTrajectoryPoint*>   (                       )
  , m_trackID    ( aTrack->GetTrackID        ()                 ) 
  , m_parentID   ( aTrack->GetParentID       ()                 )
  , m_partDef    ( aTrack->GetDefinition     ()                 ) 
  , m_4vect      ( aTrack->GetDynamicParticle()->Get4Momentum() )
  , m_stepMgr    ( 0 )
{
  ///
  GiGaTrajectoryPoint* firstPoint = 
    new GiGaTrajectoryPoint( aTrack->GetPosition() , aTrack->GetGlobalTime() );
  push_back( firstPoint );
  ///
};

/// ===========================================================================
/// constructor 
/// ===========================================================================
inline GiGaTrajectory::GiGaTrajectory ( const GiGaTrajectory & right )
  : G4VTrajectory                     (                              )
  , std::vector<GiGaTrajectoryPoint*> (                              )
  , m_trackID                         ( right.trackID       ()       )
  , m_parentID                        ( right.parentID      ()       )
  , m_partDef                         ( right.partDef       ()       )
  , m_4vect                           ( right.fourMomentum  ()       )
  , m_stepMgr                         ( right.stepMgr       ()       )
{
  // does not work on NT
  // copy(through clone) points from right 
  //    std::transform( right.begin() , right.end() , 
  //                    std::back_inserter( *this ) ,
  //                    std::mem_fun(&GiGaTrajectoryPoint::clone) );
  clear();
  for( GiGaTrajectory::const_iterator it = right.begin() ; 
       right.end() != it ; ++it )
    {  push_back( (*it)->clone() ) ; }
};

/// ===========================================================================
/// destructor 
/// ===========================================================================
inline GiGaTrajectory::~GiGaTrajectory()
{
  /// delete all points 
  for( iterator it = begin() ; it != end() ; ++it )
    { if( 0 != *it ) { delete *it ; *it = 0 ; } }  
  /// clear container 
  clear();
  ///
  m_stepMgr = 0 ;
  ///
};

/// ===========================================================================
///
/// ===========================================================================
inline int GiGaTrajectory::GetPointEntries() const 
{ return size(); } 

/// ===========================================================================
///
/// ===========================================================================
inline G4VTrajectoryPoint* GiGaTrajectory::GetPoint       ( int indx ) const  
{ return ( unsigned int ) indx < size() ? *(begin()+indx) : 0 ; }

/// ===========================================================================
/// new 
/// ===========================================================================
inline void* GiGaTrajectory::operator new(size_t)
{ return (void*) s_GiGaTrajectoryAllocator.MallocSingle(); };

/// ===========================================================================
/// delete 
/// ===========================================================================
inline void  GiGaTrajectory::operator delete(void* aTrajectory)
{ s_GiGaTrajectoryAllocator.FreeSingle( (GiGaTrajectory*) aTrajectory ); };

/// ===========================================================================
///
/// ===========================================================================
inline void GiGaTrajectory::setStepMgr( const G4SteppingManager* mgr ) 
{ m_stepMgr = mgr ; } 

/// ===========================================================================
///
/// ===========================================================================
inline const G4SteppingManager* GiGaTrajectory::stepMgr() const  
{ return m_stepMgr; } 



/// ===========================================================================
#endif  ///< GIGA_GIGATRAJECTORY_ICPP
/// ===========================================================================









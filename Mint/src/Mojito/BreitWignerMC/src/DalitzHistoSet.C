// author: Jonas Rademacker (Jonas.Rademacker@bristol.ac.uk)
// status:  Mon 9 Feb 2009 19:17:58 GMT
#include "DalitzHistoSet.h"

#include "AllPossibleSij.h"
#include "IDalitzEvent.h"
#include "NamedParameter.h"

#include "TTree.h"
#include "TFile.h"

#include <sys/types.h>
#include <sys/stat.h>

#include <fstream>

using namespace std;
using namespace MINT;

DalitzHistoSet::DalitzHistoSet() 
  : _tree(0) 
{
  makeName();
}

DalitzHistoSet::DalitzHistoSet(const DalitzHistoSet& other)
  :  std::map< std::vector<int>, DalitzHistogram>( other)
  , _tree(0)
{
  makeName();
}

void DalitzHistoSet::makeHistograms(const DalitzEventPattern& pat){

  int nDaughters = pat.numDaughters();
  AllPossibleSij sijList(nDaughters);
  
  for(namedVMap::const_iterator it = sijList.begin();
      it != sijList.end(); it++){
    DalitzHistogram h(it->second, pat);
    (*this)[it->second] = h;
  }

  return;
}
 
void DalitzHistoSet::add(const DalitzHistogram& histo, double weight){
  (*this)[histo.coord()].add(histo, weight);
  return;
}
void DalitzHistoSet::add(const DalitzHistoSet& hL, double weight){
  for(map< std::vector<int>, DalitzHistogram>::const_iterator it = hL.begin();
      it != hL.end();
      it++){
    this->add(it->second, weight);
  }
  return;
}
void DalitzHistoSet::multiply(const DalitzHistogram& histo){
  (*this)[histo.coord()].multiply(histo);
  return;
}
void DalitzHistoSet::multiply(const DalitzHistoSet& hL){
  for(map< std::vector<int>, DalitzHistogram>::const_iterator it = hL.begin();
      it != hL.end();
      it++){
    this->multiply(it->second);
  }
  return;
}
void DalitzHistoSet::divide(const DalitzHistogram& histo){
  (*this)[histo.coord()].divide(histo);
  return;
}
void DalitzHistoSet::divide(const DalitzHistoSet& hL){
  for(map< std::vector<int>, DalitzHistogram>::const_iterator it = hL.begin();
      it != hL.end();
      it++){
    this->divide(it->second);
  }
  return;
}

void DalitzHistoSet::addEvent(const IDalitzEvent* evtPtr, double weight){
  if(0 == evtPtr) return;
  int ndgtr(evtPtr->eventPattern().numDaughters());
  if(this->empty() && ndgtr > 2) makeHistograms(evtPtr->eventPattern());

  for(map< std::vector<int>, DalitzHistogram>::iterator 
	it = this->begin();
      it != this->end();
      it++){
    it->second.addEvent(evtPtr, weight);
  }
  return;
}

void DalitzHistoSet::scale(double sf){
  if(this->empty()) return;
  for(map< std::vector<int>, DalitzHistogram>::iterator 
	it = this->begin();
      it != this->end();
      it++){
    it->second.scale(sf);
  }
  return;
}

void DalitzHistoSet::setTitle(const std::string& title){
  if(this->empty()) return;
  for(map< std::vector<int>, DalitzHistogram>::iterator 
	it = this->begin();
      it != this->end();
      it++){
    it->second.setTitle(title);
  }
  return;
}

void DalitzHistoSet::clearAllHistos(){
  if(this->empty()) return;
  for(map< std::vector<int>, DalitzHistogram>::iterator 
	it = this->begin();
      it != this->end();
      it++){
    it->second.clearHisto();
  }
  return;
}

const std::string& DalitzHistoSet::makeName(){
  _name = "DalitzHistoSet";
  return _name;
}

const std::string& DalitzHistoSet::name() const{
  return _name;
}

const std::string& DalitzHistoSet::dirName() const{
  return _name;
}

bool DalitzHistoSet::save(const std::string& filename) const{
  TFile f(filename.c_str(), "RECREATE");
  f.cd();
  for(map< std::vector<int>, DalitzHistogram>::const_iterator 
	it = this->begin();
      it != this->end();
      it++){
    if(0 == it->second.histo()) continue;
    it->second.histo()->Write();
  }
  f.Close();
  return true;
}

bool DalitzHistoSet::makeDirectory(const std::string& asSubdirOf)const{
  /*
    A mode is created from or'd permission bit masks defined
     in <sys/stat.h>:
           #define S_IRWXU 0000700     RWX mask for owner 
           #define S_IRUSR 0000400     R for owner 
           #define S_IWUSR 0000200     W for owner 
           #define S_IXUSR 0000100     X for owner 

           #define S_IRWXG 0000070     RWX mask for group 
           #define S_IRGRP 0000040     R for group 
           #define S_IWGRP 0000020     W for group 
           #define S_IXGRP 0000010     X for group 

           #define S_IRWXO 0000007     RWX mask for other 
           #define S_IROTH 0000004     R for other 
           #define S_IWOTH 0000002     W for other 
           #define S_IXOTH 0000001     X for other 

           #define S_ISUID 0004000     set user id on execution 
           #define S_ISGID 0002000     set group id on execution 
           #define S_ISVTX 0001000     save swapped text even after use
   */

  mode_t mode = S_IRWXU | S_IRWXG | S_IRWXO 
              | S_ISUID | S_ISGID; 
  // see above for meaning. I want everybody to be allowed to read/write/exec.
  // Not sure about the last two bits.

  int zeroForSuccess = 0;
  zeroForSuccess |= mkdir( (asSubdirOf ).c_str(), mode );
  zeroForSuccess |= mkdir( (asSubdirOf + "/" + dirName() ).c_str(), mode );
  return (0 == zeroForSuccess);
}

std::string DalitzHistoSet::fullDirListFname(const std::string& 
					     asSubdirOf) const{
  return asSubdirOf + "/" + dirName() + "/" + "directoryList.txt";
}
bool DalitzHistoSet::saveAsDir(const std::string& asSubdirOf) const{
  bool dbThis=false;

  bool sc=true;

  makeDirectory(asSubdirOf);
  std::string dir = asSubdirOf + "/" + dirName();
  
  std::vector<std::string> directoryList;
  for(map< std::vector<int>, DalitzHistogram>::const_iterator 
	it = this->begin();
      it != this->end();
      it++){
    sc &= it->second.saveAsDir(dir);
    directoryList.push_back(it->second.dirName());
  }
  
  NamedParameter<std::string> dirNames("DirectoryList"
				       , NamedParameterBase::QUIET);
  dirNames = directoryList;

  ofstream os( fullDirListFname(asSubdirOf).c_str() );
  if(os.bad()){
    cout << "ERROR in DalitzHistoSet::saveAsDir of \n\t" << name()
	 << "\n\t unable to create file: "
	 << "\n\t" << fullDirListFname() << endl;
    return false;
  }
  os << name()
     << '\n' << dirNames
     << endl;
  os.close();

  if(dbThis){
    cout << "I've just written this: "
	 << name()
	 << '\n' << dirNames
	 << endl;
    cout << "to this file: " << fullDirListFname(asSubdirOf) << endl;
  }
  return sc;
}

bool DalitzHistoSet::retrieveFromDir(const std::string& asSubdirOf){
  bool dbThis=false;
  bool sc=true;

  makeDirectory(asSubdirOf);
  //path = asSubdirOf + "/" + dirName();
  NamedParameter<std::string> dirNames("DirectoryList"
				       , fullDirListFname(asSubdirOf).c_str()
				       );
  dirNames.reloadFile(fullDirListFname(asSubdirOf).c_str());
  std::string path=asSubdirOf + "/" + dirName();
  for(int i=0; i < dirNames.size(); i++){
    DalitzHistogram hs;    
    hs.retrieveFromDir( path, dirNames.getVal(i).c_str() );
    if(dbThis) cout << "hs.pattern()" << hs.pattern() << endl;
    this->add(hs);
  }
  if(dbThis){
    cout << "after adding:" << endl;
    for(std::map< std::vector<int>, DalitzHistogram>::const_iterator it =
	  this->begin(); it != this->end(); it++){
      cout << "\n" << it->second.pattern() << endl;
    }

  }
  return sc;
}

bool DalitzHistoSet::draw(const std::string& baseName
			  , const std::string& drawOpt
			  , const std::string& format
			  ) const{
  bool sc=true;
  for(map< std::vector<int>, DalitzHistogram>::const_iterator 
	it = this->begin();
      it != this->end();
      it++){
    sc &= it->second.draw(baseName, drawOpt, format);
  }
  return sc;
}
bool DalitzHistoSet::drawWithFit(const DalitzHistoSet& fit
				 , const std::string& baseName // =""
				 , const std::string& format // ="eps"
				 ) const{
  bool sc=true;
  for(map< std::vector<int>, DalitzHistogram>::const_iterator 
	it = this->begin();
      it != this->end();
      it++){
    map< vector<int>, DalitzHistogram >::const_iterator jt = fit.find(it->first);
    if(jt == fit.end()) continue;
    sc &= it->second.drawWithFit(jt->second, baseName, format);
  } 
  return sc;
}
// operators 
DalitzHistoSet& DalitzHistoSet::operator*=(double sf){
  this->scale(sf);
  return *this;
}
DalitzHistoSet DalitzHistoSet::operator*(double sf) const{
  DalitzHistoSet newSet(*this);
  newSet *= sf;
  return newSet;
}
DalitzHistoSet operator*(double sf, const DalitzHistoSet& dhs){
  DalitzHistoSet newSet(dhs);
  newSet *= sf;
  return newSet;
}

DalitzHistoSet& DalitzHistoSet::operator/=(double sf){
  this->scale(1./sf);
  return *this;
}
DalitzHistoSet DalitzHistoSet::operator/(double sf) const{
  DalitzHistoSet newSet(*this);
  newSet /= sf;
  return newSet;
}

DalitzHistoSet& DalitzHistoSet::operator+=(const DalitzHistoSet& rhs){
  this->add(rhs);
  return *this;
}
DalitzHistoSet DalitzHistoSet::operator+(const DalitzHistoSet& rhs) const{
  DalitzHistoSet newSet(*this);
  newSet += rhs;
  return newSet;
}
DalitzHistoSet& DalitzHistoSet::operator-=(const DalitzHistoSet& rhs){
  this->add(rhs, -1.0);
  return *this;
}
DalitzHistoSet DalitzHistoSet::operator-(const DalitzHistoSet& rhs) const{
  DalitzHistoSet newSet(*this);
  newSet -= rhs;
  return newSet;
}

DalitzHistoSet& DalitzHistoSet::operator*=(const DalitzHistoSet& rhs){
  this->multiply(rhs);
  return *this;
}
DalitzHistoSet DalitzHistoSet::operator*(const DalitzHistoSet& rhs) const{
  DalitzHistoSet newSet(*this);
  newSet *= rhs;
  return newSet;
}
DalitzHistoSet& DalitzHistoSet::operator/=(const DalitzHistoSet& rhs){
  this->divide(rhs);
  return *this;
}
DalitzHistoSet DalitzHistoSet::operator/(const DalitzHistoSet& rhs) const{
  DalitzHistoSet newSet(*this);
  newSet /= rhs;
  return newSet;
}

//

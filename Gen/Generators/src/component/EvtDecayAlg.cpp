// $Id: EvtDecayAlg.cpp,v 1.3 2005-10-03 09:40:09 robbep Exp $

// include files
// This class
#include "EvtDecayAlg.h"
// STD Library
#include <algorithm>
// From Gaudi
#include "GaudiKernel/AlgFactory.h"
// From Event
#include "Event/HepMCEvent.h"
// Local
#include "Generators/IEvtGenTool.h"
#include "Generators/HepMCUtils.h"

static const AlgFactory<EvtDecayAlg>    Factory;
const IAlgFactory& EvtDecayAlgFactory = Factory;

//============================================================================
// Implementation of algorithm EvtDecayAlg
//============================================================================

//============================================================================
// constructor
//============================================================================
EvtDecayAlg::EvtDecayAlg(const std::string& name, ISvcLocator* pSvcLocator) :
  GaudiAlgorithm(name, pSvcLocator) ,
  m_evtTool( 0 ) {
  // Property IsolateSignal
  // If true, signal B hadron decay tree will be put in a specific location
  declareProperty( "IsolateSignal" , m_isolateSignal = false ) ;
  declareProperty( "HepMCEventLocation", m_eventLoc = HepMCEventLocation::Default );
}

//=============================================================================
// Destructor
//=============================================================================
EvtDecayAlg::~EvtDecayAlg( ) {}

//============================================================================
// initialize method
//============================================================================
StatusCode EvtDecayAlg::initialize() {
  StatusCode sc = GaudiAlgorithm::initialize( ) ;
  if ( sc.isFailure() ) return Error( "Base class is not initialized" , sc ) ;
  
  // Retrieve the shared EvtGen tool
  m_evtTool = tool< IEvtGenTool > ( "EvtGenTool" ) ;
  debug() << "EvtDecayAlg initialized" << endreq;
  return StatusCode::SUCCESS;
}

//============================================================================
// execute method
//============================================================================
StatusCode EvtDecayAlg::execute() {
  // Location of the event already generated by Pythia
  HepMCEvents * hepMCptr = get< HepMCEvents >( m_eventLoc ) ;
  
  if ( 0 == hepMCptr ) info() << "No HepMCptr" << endreq ; 
  else {
    HepMCEvents::iterator it;
    for ( it = hepMCptr->begin() ; it != hepMCptr->end() ; ++it ) {
      // copy iterator in another iterator to sort it
      GenParticles theHepMCVector ;
      HepMC::GenEvent * pEvt = (*it) -> pGenEvt() ;
      HepMCUtils::SortHepMC( theHepMCVector , pEvt -> particles_size() ,
                             pEvt -> particles_begin() , 
                             pEvt -> particles_end  () ) ;
      
      GenParticles::iterator itp ;
      for( itp = theHepMCVector.begin() ; itp != theHepMCVector.end() ; 
           ++itp ) {                
        //
        // This is the main loop.
        // We iterate over particles and we look for ones that
        // should be decayed with EvtGen.
        //
        // status == 1     - Pythia particle
        // status == 888   - particle to be decayed by EvtGen
        // status == 777   - particle already decayed by EvtGen
        // status == 999   - stable particle produced by EvtGen
        // status == 889   - signal particle whose decay is predefined
        //                        ( the Pythia particle)
        // status == 998   - predefined decay (EvtGen particle)
        
        // Decay with EvtGen only if it has no daughter
        if ( ( 888 == (*itp)->status() ) && ( 0 == (*itp)->end_vertex() ) ) {
          HepMC::GenEvent* hepMCevt=(*it)->pGenEvt();
          // The particle produced by Pythia which has to 
          // be decayed by EvtGen
          HepMC::GenParticle* hepMCpart=*itp;
          
          // disable the possibility to change b flavour inside
          // EvtGen for generic decays.        
          m_evtTool->disableFlip() ;
          
          // Generate decay with EvtGen
          StatusCode sc = m_evtTool->generateDecay( hepMCevt , hepMCpart ) ;  
          if ( ! sc.isSuccess() ) 
            return Error( "Unable to decay particle in EvtGen" , sc ) ;

        } else if ( 889 == (*itp)->status() ) {
          // This is the signal particle. It has already been 
          // decayed in SignalDecayAlg but at rest. One has
          // now to put it in the correct frame which is the
          // one of the particle produced by Pythia.

          // Find in Event Store the corresponding decay
          HepMCEvents * hepMCptrsignal = 
            get< HepMCEvents >( "/Event/Gen/SignalDecay" ) ;
          
          if ( 0 == hepMCptrsignal ) 
            return Error( "Unable to locate predefined decay." ) ;
          
          if ( 1 != hepMCptrsignal->size() ) 
            return Error( "More than one predefined decay." ) ;
          
          HepMCEvents::iterator itsignal = hepMCptrsignal->begin() ;
          HepMC::GenEvent * pEvt = (*itsignal)->pGenEvt() ;
          HepMC::GenEvent::particle_const_iterator itpsignal ;
          // Look for particles with status = 998
          // There is only one
          for ( itpsignal = pEvt -> particles_begin() ;
                itpsignal != pEvt -> particles_end() ; ++itpsignal ) {
            if ( 998 == (*itpsignal)->status() ) {
              // boost the particle tree to the Pythia particle
              // frame.
              HepMC::GenEvent * theEvent = (*it)->pGenEvt() ;
              // The particle produced by Pythia
              HepMC::GenParticle * theMother = (*itp) ;
              
                  // The particle produced by EvtGen in SignalDecayAlg
              HepMC::GenParticle * theSignal = (*itpsignal) ;
              
              // The boost vector to apply to theSignal
              Hep3Vector theVector = theMother->momentum().boostVector();
              
              // Check if masses agree
              if ( fabs( theMother -> momentum() . m() -
                         theSignal -> momentum() . m() ) > 1. * eV ) {
                warning() << "The Pythia and EvtGen particles "
                          << "do not have the same mass !"
                          << endreq ;
                warning() << "This can happen when the signal"
                          << " particle is a resonance, with forced"
                          << " fragmentation."
                          << endreq ;
                warning() << "The generation might not be "
                          << "correct in this case !"
                          << endreq ;
              }
              
              // Boost theSignal particle to the correct frame
              // and substitute the Pythia produced particle
              // with it
              StatusCode sc = boostTree( theMother, theSignal, theEvent, 
                                         theVector ) ;
              if ( ! sc.isSuccess() ) 
                return 
                  Error ("Could not boost decay tree to Pythia particle." , 
                         sc ) ;
              
              if ( m_isolateSignal ) {
                // Isolate signal decay tree in a specific location
                sc = isolateSignal( theMother ) ;  
                if ( ! sc.isSuccess() ) 
                  return Error( "Could not register signal" , sc ) ;
              }
              // There is only one predifined decay tree
              // So we can exit now   
              break ;
            }
          }
        }
      }
    }
  }
  return StatusCode::SUCCESS;
}

//=============================================================================
// Finalize method
//=============================================================================
StatusCode EvtDecayAlg::finalize() {
  debug() << "EvtDecayAlg finalized" << endreq;
  return GaudiAlgorithm::finalize( ) ;
}

//=============================================================================
// Boost the Tree theSignal to theVector frame and attach it to theMother
//=============================================================================
StatusCode EvtDecayAlg::boostTree( HepMC::GenParticle * theMother ,
                                   const HepMC::GenParticle * theSignal ,
                                   HepMC::GenEvent * theEvent ,
                                   const Hep3Vector & theVector ) const {
  StatusCode sc = StatusCode::SUCCESS ;
  
  if ( 0 != theSignal->end_vertex() ) {
    if ( 0 != theMother->end_vertex() ) 
      return Error( "The Mother already has an end_vertex." ) ;
    
    if ( 0 == theSignal->production_vertex() ) 
      return Error( "The particle has no production vertex !" ) ;
    
    // Displacement in original frame
    HepLorentzVector position = theSignal->end_vertex()->position() -
      theSignal->production_vertex()->position() ;
    // Displacement in new frame after boost.
    HepLorentzVector newPosition = position.boost( theVector ) ;
    
    // Create new HepMC vertex after boost and add it to the current event    
    HepMC::GenVertex * newVertex = 
      new HepMC::GenVertex( newPosition + 
                            theMother->production_vertex()->position() ) ;
    theEvent->add_vertex( newVertex ) ;
    newVertex->add_particle_in( theMother ) ;
    
    // copy iterator in another iterator to sort it
    GenParticles theHepMCVector ;
    HepMC::GenVertex * sVertex = theSignal->end_vertex() ;
    HepMCUtils::SortHepMC( theHepMCVector , sVertex -> particles_out_size()  , 
                           sVertex->particles_begin( HepMC::children ) ,
                           sVertex->particles_end  ( HepMC::children ) );

    GenParticles::iterator child ;
    for ( child = theHepMCVector.begin( ) ; child != theHepMCVector.end( ) ; 
          ++child ) {
      // Boost all daughter particles and create a new HepMC particle
      // for each daughter
      HepLorentzVector momentum = (*child) -> momentum() ;
      HepLorentzVector newMomentum = momentum.boost( theVector ) ;
      int id = (*child)->pdg_id() ;
      
      HepMC::GenParticle * newPart =
        new HepMC::GenParticle( newMomentum , id , (*child)->status() ) ;
      
      newVertex->add_particle_out( newPart ) ;
      
      HepMC::GenParticle * theNewMother = newPart ;
      HepMC::GenParticle * theNewSignal = (*child) ;
      
      // Recursive call to boostTree for each daughter
      sc = boostTree( theNewMother , theNewSignal , theEvent , theVector ) ;
      if ( ! sc.isSuccess() ) return sc ; 
    }
  }
  return sc ;
}

//=============================================================================
// Create a container for the B hadron signal decay
//=============================================================================
StatusCode EvtDecayAlg::isolateSignal( const HepMC::GenParticle 
                                       * theParticle ) const {
  StatusCode sc = StatusCode::SUCCESS ;
  // Create a new event to contain the isolated signal decay tree
  HepMCEvent * mcevt = new HepMCEvent( name() , 1 , 1 ) ;
  HepMC::GenEvent * hepMCevt = mcevt -> pGenEvt() ;
  
  if ( 0 == theParticle -> production_vertex() ) 
    return Error( "BHadron has no production vertex." ) ;
  
  // Create a new vertex and a new HepMC Particle for the root particle
  // (a copy which will be associated to the new HepMC Event)
  
  HepMC::GenVertex * newVertex =
    new HepMC::GenVertex( theParticle -> production_vertex() -> position() ) ;
  
  hepMCevt -> add_vertex( newVertex ) ;
  
  HepMC::GenParticle * theNewParticle =
    new HepMC::GenParticle( theParticle->momentum() , theParticle->pdg_id() ,
                            theParticle->status()   ) ;
  
  newVertex -> add_particle_out( theNewParticle ) ;

  // Associate the new Particle to the HepMC event   
  // and copy all the tree to the new HepMC event
  sc = fillHepMCEvent( hepMCevt , theNewParticle , theParticle ) ;

  if ( ! sc.isSuccess() ) 
    return Error( "Could not fill hepMC event for BHadronTree" , sc ) ;

  // Check if the container already exists
  
  if ( exist< HepMCEvents > ( "/Event/Gen/BHadronTree" ) )
    return Error( "BHadronTree already exist !" ) ;
  
  HepMCEvents * hepVect = new HepMCEvents ;
  hepVect -> insert( mcevt ) ;

  // Register new location and store new HepMC event
  sc = put( hepVect , "/Event/Gen/BHadronTree" ) ;
  if ( ! sc.isSuccess() ) 
    return Error( "Could not register BHadronTree" ) ;
  
  return sc ;
}

//=============================================================================
// Fill HepMC event from a HepMC tree
//=============================================================================
StatusCode EvtDecayAlg::fillHepMCEvent( HepMC::GenEvent    * theEvent ,
                                        HepMC::GenParticle * theNewParticle ,
                                        const HepMC::GenParticle * 
                                        theOldParticle ) const {
  StatusCode sc = StatusCode::SUCCESS ;
  //
  // Copy theOldParticle to theNewParticle in theEvent
  // theNewParticle already exist and is created outside this function
  HepMC::GenVertex * oVertex = theOldParticle->end_vertex() ;
  if ( 0 != oVertex ) {
    // Create decay vertex and associate it to theNewParticle
    HepMC::GenVertex * newVertex = 
      new HepMC::GenVertex( oVertex -> position() ) ;
    theEvent -> add_vertex( newVertex ) ;
    newVertex -> add_particle_in( theNewParticle ) ;

    // copy iterator in another iterator to sort it
    GenParticles theHepMCVector ;
    HepMCUtils::SortHepMC( theHepMCVector , oVertex->particles_out_size() ,
                           oVertex->particles_begin( HepMC::children ),
                           oVertex->particles_end  ( HepMC::children ));
    
    GenParticles::iterator child ;
    for (child = theHepMCVector.begin( ) ; child != theHepMCVector.end( ) ; 
         ++child ) {
      // Create a new particle for each daughter of theOldParticle
      HepMC::GenParticle * newPart =
        new HepMC::GenParticle ( (*child) -> momentum () ,
                                 (*child) -> pdg_id ()   ,
                                 (*child) -> status ()   ) ;
      newVertex -> add_particle_out( newPart ) ;
      
      HepMC::GenParticle * theChild = (*child) ;
      // Recursive call : fill the event with the daughters
      sc = fillHepMCEvent( theEvent , newPart , theChild ) ;
      
      if ( ! sc.isSuccess() ) return sc ;
    }
  }
  return sc ;
}
